
## 专栏前言

本专栏的深度学习内容大部分基于 [山东大学计算机科学与技术学院](https://www.cs.sdu.edu.cn/) 崔学峰老师在寒假期间为大一新生开设的深度学习自修课程，此课程使用 Python 编程语言与其深度学习包以及老师提供的 Ubuntu 服务器，会相应补充关于服务器、环境配置等课程不会教授的内容，以及非计算机专业的同学学习此课程可能需要了解的一些计算机科学的基础知识，旨在帮助大家更好的学习。

有关计算机科学的基础知识主要根据一些专业资料与本人对相关知识的理解，若有不当之处，对文章内容有疑问，请留言或者通过博客下方的邮箱和账号联系我。

面向的对象：

- 计算机专业对深度学习感兴趣的大一学生
- 非计算机专业，出于兴趣或工作需要了解计算机基础知识或深度学习的人

本专栏的写作目的是帮助理解计算机科学与深度学习的内容，以及掌握其中的关键部分，而不是科普。所以在文章中我会给出大部分专业名词的严格定义（对于一些高中就学过的概念不会再作解释），非计算机专业的同学初次接触可能会觉得有困难，这些都是正常的，知识只有不断回顾，才能在你脑中留下深刻印象。

> 💡 **NOTE**: 下面有一些技巧可能帮助你阅读以及理解本专栏的内容：
> 
> - 请关注给出的专业名词的英文。一些名词的中文翻译有可能无法准确地描述其含义，并且多个不同名词可能存在相同的中文翻译或中文简称，然而它们是不同的东西。英文可以帮助你记住并理解它们之间的不同
> - 阅读专业名词定义时，建议首先找到宾语，即“它属于什么”，然后再查看定语，即描述其特殊性的内容。比如：
>   - 形式语言：一个字母表上的某些有限长字符串的集合
>   - 形式语言是集合这一概念中的一个子集
>   - 形式语言这个子集中的元素必须是一个字母表上的某些有限长字符串
> - 如果你遇到了不理解的内容，可以暂时跳过，一些对于初学者来说较为深入的讲解并不会影响你对后续内容的理解，并且你不需要掌握所有内容。在学习计算机的过程中，你会对很多概念逐渐熟悉起来。

下面是写给对计算机不太了解的非计算机专业同学的计算机科学基础知识，有基础的同学可以选择性阅读。

## 计算与语言：尝试解决与描述问题的语法

### 计算是为了解决问题，但不能解决所有问题

什么是计算？为什么要计算？什么是计算机？什么是计算机科学？

在这里我不会给计算（Compute）下一个严格的定义，区别于通常在数学中所说的计算（Calculate），计算机科学中的 *计算（Compute）* 可以被认为是 **执行一个算法的过程**，它包含了数学中的计算概念。

这里有几个值得注意的地方：

- 这里使用的名词 *算法* 并没有给出对应的英文，在下文中你会看到两种算法的名词，而这里所说的算法同时包括它们。这里的算法，可以被理解为一些 **指令的序列**，简单而言，指令就是告诉你（或计算机）这一步应该做什么事情。一份菜谱也可以被认为是指令的序列，它告诉你完成一道菜需要先做什么，再做什么，最后做什么。
- 执行算法的可能是人，也可能是计算机。在以前只有人可以执行算法，而计算机的诞生与发展大大提高了计算的效率，计算机最擅长的就是快速处理大量繁重的任务，使以前许多不可能的任务成为可能，使人类可以从许多无聊的工作中解脱出来。~~所以 21 世纪了小学生为什么还需要做大量无用的算数题。~~

什么问题是可以解决的？什么问题是无法解决的？这个问题相当于：
什么问题是可以计算的？什么问题是不可计算的？

~~比如我们在幼儿园就学过的一个问题~~：已知三角形的底边长和高长，求三角形的面积？

这个问题使用 **数学公式** 就可以解决，让我们先来把这个问题（Problem）描述成一个标准形式：

- 输入（Input）：三角形的底边长 $l$，高长 $h$（2 个参数）
- 输出（Output）：三角形的面积 $S$

使用公式 $S=\frac{1}{2}lh$ 就可以解决这个问题，进一步地，我们可以把这个公式描述成一个函数：

$$
S=f(l, h)=\frac{1}{2}lh
$$

可以看到函数的参数即问题的输入，函数的值即问题的输出。

但是数学公式并不能解决所有的问题，比如我想知道某个路径，比如 `C:\Users\<user-name>\Roaming` 下的所有文件，这时就需要比公式更强大的算法。

在程序设计中通常将这一算法或称过程（Process）描述成类似数学中函数的形式，通常编程语言中也称其为函数（Function）

$$
output=myProcess(input_1, input_2, ...)
$$

特别地，过程可以没有输出，只是执行一些工作。

如下图所示，可以把过程理解为一个黑箱，将输入放进黑箱中得到输出。黑箱中执行的转换操作就是算法/过程

<img src="/img/beginner/function.png" width = "450" height = "400" alt="function" align=center />

计算能够解决（Solve）很多问题！但不是全部，比如“明天天气如何？”。尽管你可以方便地获取天气预报，然而我们都知道天气预报~~很多时候都~~不准——换句话说，它不保证给你正确的结果。但是所谓 *解决（Solve）* **一类** 问题，我们必须对此类问题 **所有可能的输入** 得到 **正确** 的结果（输出）！

相应地，在计算机科学中，问题被分为可计算的与不可计算的。*可计算（Computable）问题* 指的就是可以找到解决这类问题的算法的所有问题类的集合。

> 💡 **NOTE**: 这里所说的广泛意义上的算法（可能说过程更为合适）不一定解决问题，它只是描述一个方案。然而算法（描述）乃至程序（实现）的正确性可能是很难证明的！甚至有些问题是不可计算的，比如这门课要讲的深度学习，作为人工智能当下大热的一个技术，致力于（从概率意义上）得到很多 **不可** 计算的问题的结果，或者被应用于加速得到一些可计算但 **难** 计算问题结果的过程（而不一定正确）。

到这里你应该对计算是什么有了一个大概的印象，但是为什么要计算？从前面的介绍中你可以总结出其中一个原因——因为有些问题是纯粹的数学或其他自然科学、工程学无法解决的。

还有一些问题是数学和其他自然科学、工程学尚未找到解决方法的（比如微分方程的解析解），我们可以借助现代的计算机来进行大量复杂的计算得到近似结果（比如微分方程的数值解），很多时候近似结果是足够好的。

当然，只有计算仍然有更多的问题仍然无法解决，我们需要心理学、文学、人类学等更丰富的学科。而现在以人工智能和数据科学为代表的诸多计算机领域也逐渐向多学科交叉融合的方向发展，通常许多工程如机器翻译都需要计算机科学家与工程师和其他专业领域，如语言学、社会学、艺术学的专家合作，在这些特定领域的知识也称为 domain knowledge。

### 计算机科学的语言：形式语言

要认识计算机科学，首先要了解的概念就是 *语言（Language）*。计算机专业大一新生入学的第一门专业基础课就是程序设计语言，即通常说的编程语言。

日常生活中我们提到语言通常是指 *自然语言（Natural Language）*，即平时交流使用的语言，这类语言不是人为设计（虽然有人试图强加一些规则）而是自然进化的。而计算机科学中的语言通常指 *形式语言（Formal Language）*，是用 **精确** 的数学或机器可处理的公式 **定义** 的语言。编程语言就是一种形式语言，编程语言及其相关概念会在下文中详细解释。

> 💡 **NOTE**: 在计算机的某些领域，如 *自然语言处理（Natural Language Processing，NLP）* 中，会指出我们处理的对象即自然语言，而不是一些其他领域中研究的的形式语言或者编程语言

计算机的一个基础研究方向 *理论计算机科学（Theoretical Computer Science，TCS）* 中 *计算理论（Theory of Computation TOC）* 分支的 **研究对象** 就是语言，更准确地说是形式语言。

形式语言一般有两个方面：*语法（Syntax）* 和 *语义（Semantics）*。专门研究语言的语法的数学和计算机科学分支叫做形式语言理论，它只研究语言的语法而不致力于它的语义。

在形式语言理论中，*形式语言* 是一个**字母表上**的某些**有限长字符串**的**集合**，这个集合本身可以是无限的，而其中的字符串长度必须是有限的。

一个 *字符串（String）* 就一个是**零个或多个字符**组成的**有限序列**，与集合相区别，序列中的元素（这里就是字符）必须是有序的。而字符必须是在字母表中定义的字符，*字母表（Alphabet）* 是一个字符集合，此概念类似于英语中的字母表，但是这里说的字母表可以（并且必须！）包含任意你在语言中需要的字符（也可以自定义），比如空格、?、$、:、甚至😅、😘和🤡（只要你需要用到它们）。在个形式语言的意义上，自然语言中的标点符号也属于形式语言字母表中的字符。当你想要构造一个语言的时候，字母表是你首先应该考虑的东西：我的语言中使用哪些符号？

> 💡 **NOTE**: 零个字符组成的字符串通常称为 *空字符串* 或简称 *空串*，用符号 $\epsilon$ 表示

***

- 字母表的例子：
  - {0, 1, 2, 3, 4, a, b, c, &, *, o}
  - {🐮, 羊, 虎, ￥}

- 字符串的例子：
  - abc*70-p
  - I can do it!
  - 哔哩哔哩 (゜-゜)つロ 干杯~-bilibili

- 语言的例子（为方便阅读，采用使用""将字符串包围起来的约定）：
  - {"He was like a cock who thought the sun had risen to hear him crow.", "I wandered lonely as a cloud.", ...}
  - {"言必信，行必果。", "见贤思齐焉，见不贤而内自省也。", "益者三友：友直、友谅、友多闻。", ...}
  - {"adijo11,ndmf@!a", "passwd"}

***

形式语言这一看似简单的定义表达了甚至包括自然语言在内的所有语言的一个通用精确定义。比如使用中文表达所有可能的句子就组成了中文这一语言（则这一形式语言当然是一个无限的集合！）。

> 💡 **NOTE**: 可以把 TOC 的研究内容与代数做一个对比：TOC 的研究对象是 *语言*，代数的研究对象是 *数*，在数上可以进行加减乘除以及更复杂的运算，而对于语言我们仍然可以进行其他定义形式的运算（比如对集合的运算并交补等，因为一个语言就是一个集合！）。事实上无论是集合及其操作还是语言及其操作，如果你了解过抽象代数（近世代数）这门学科，就马上能明白它们都是代数的一种，我们通常所说的代数只是代数中一个很小的以数作为研究对象的子集。

在理论计算机科学中，形式语言常常被用来 **描述** 一类问题（Problem），比如：所有连通的无向图构成一个语言。

这样的概念对于不了解 TOC 的人来说可能难以理解：[图（Graph）](https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)) 作为图论中的一种数学结构或者计算机科学中的一种数据结构，它和字符串有什么关系呢？图如何能构成一个语言呢？（注意：形式语言中的元素被规定为字符串）

> 💡 **NOTE**: 如果你不了解什么是图（Graph），只需要知道它是像多面体、函数这样有数学定义的研究对象

为了理解这一内容，下面要介绍计算机科学中一个重要的概念—— **编码** 

## 编码：理解语义

编码的概念在计算机的世界中随处可见，什么是编码？为什么要编码？如何编码？我们先不着急解释编码的概念，而是从工程实践的角度来了解一下计算机的组成—— **现代电子计算机的硬件结构** 。

> 💡 **NOTE**: 请注意这里需要特别关注限定词：
> 
> - *现代*：历史上的计算机可能采用的是十进制而非二进制，虽然十进制同样可以用于编码与计算，但是现代计算机均采用 **二进制**（为什么？），下面的讨论也基于二进制。并且现代计算机采用冯诺依曼架构，其核心思想是 **存储程序**，这是实现计算 **自动化** 的关键。
> - *电子*：区别于 TCS 中研究前沿的量子计算机或生物计算机，这里讨论的是目前能够被制造出来并且广泛应用的电子计算机的硬件结构，其计算能力对应于计算复杂性理论中的确定性图灵机。简单来说，量子计算机与生物计算机的计算能力是现在的电子计算机的指数级别倍（是真正的指数级别！）

### 二进制：硬件的选择

*进位制 或 进制（**Positional notation** or **positional numeral system**）* 是一种 **数字系统**，其中每一个 *数字* 被表示为一个 **数符的序列**，其 **数字（Number）的值** 是每一位 **数符（Digit）的值** 乘以由其所处位置（Position）确定的因子——**位权（Weight）** 得到的结果的总和，即：

$$
valueOfNumber = \sum_{i=0}^{n} (vauleOfDigit[i]*weight[i])
$$

> 💡 **NOTE**: 位置计数从 0 开始，而不是我们通常认为的 1，在计算机科学中计数普遍从 0 开始，当你开始编程的时候，就会对这一点深有体会。

而你选择的 *基（Radix）* （即某某进制）决定了数符的数量与位权，$r$ 进制数的数符为 $0, 1, ..., r-1$，其第 $i$ 位上的权重为 $r^i$。

则进一步地上面的式子可以表示为：

$$
valueOfNumber_{(Radix)} = \sum_{i=0}^{n} (vauleOfDigit[i]*Radix^{i})
$$

这是一个以 Radix 为基的 $n+1$ 位 Radix 进制数的表示。当以 10 为基的时候，这就是我们中学学过的 *科学计数法*

> 💡 **NOTE**: 为什么要使用进位制？如果你不使用进位制，需要为所有的数指定一个符号，但数是无限多的，你不可能为所有数都指定一个符号。而进位制可以让你使用有限的符号（即数符 Digit，其数量等于你使用的进位制的基 Radix）来表示无限多的数。

****

一个 6 位二进制数的例子：

$$
101101_{(2)} = 1 * 2^5 + 0 * 2^4 + 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0
$$

十进制数 $1125_{(10)}$：

<img src="/img/beginner/PosNotation.PNG" width = "300" height = "300" alt="进位制示意图" align=center />

如果把基换成 8 得到八进制数 $1125_{(8)}$：

$$
1125_{(8)} = 1 * 8^3 + 1 * 8^2 + 2 * 8^1 + 5 * 8^0
$$

实际上进位制表示直接给出了将其他进制数转换成十进制的方法，你可以以十进制的表示法计算八进制数 $1125_{(8)}$ 的值，看看它和十进制数 $1125_{(10)}$ 有什么区别？

****

使用相同的数符排列来表示不同的数字（含义）——这就是 **编码的一个例子**。好比双方进行私钥加密通信，你们只有共同认定一个加密与解密规则才能成功进行通信，这就是所谓的 **语义**。当和别人讨论问题时同样，你们最好先确定双方对讨论的内容有一个共同的认知或者定义。

<img src="/img/beginner/say.PNG" width = "300" height = "300" alt="你这说的什么猪话" align=center />

> 💡 **NOTE**: 你可能注意到这里为了方便不熟悉其他进制的同学理解，使用的基与数符的表述仍然是十进制的符号（比如上面的位权 $2^5$，严格来说应该表示为 $2^{101}$，因为 5 不是二进制的数符）。虽然表述不同，背后代表的意义是相同的。比如中文中的“奶牛”可以使用英文表述为 "cow"，但它们代指的是同一件事物。这对于理解各进制之间的转化是一关键。

> ❓ **QUESTION**:上面的进位制表示看起来非常清楚，但是仍然有一些细微的问题：当数字的位数超过了其进制的基时，会出现 **自身定义自身** 的情况。比如 3 位二进制数 $111_{(2)} = 1 * 2^{10} + 1 * 2^{1} + 1 * 2^{0}$，请注意最高位上的位权：$2^{10}$，这里 10 同样使用了进位制表示。请思考：是定义出错了吗？如果是定义出错，如何修改定义使其正确？如果定义正确，如何解释这一现象？对这个问题的回答涉及到理论计算机科学与程序设计中一个十分重要的概念，如果你没有计算机基础，可以尝试上网搜索我给出的关键信息。

> ⚠️️ **NOTICE**：另外请注意，上面的定义是对整数的定义，若考虑实数（既有整数部分又有小数部分），应该将定义更改成：
> $$
> valueOfNumber_{(Radix)} = \sum_{i=-m}^{n} (vauleOfDigit[i]*Radix^{i})
> $$
> 其中 $n, m$ 都是正数（也可能是 $\inf$）。可以理解为，位权的幂次取自整数轴：$..., -3, -2, -1, 0, 1, 2, 3, ...$

为什么现代计算机采用的不是通常我们运算用的十进制而是二进制？计算机的理论模型与进位制并无关系，然而计算机的 **实现** 是一个 **工程** 问题，需要和真实的物理环境打交道。现代电子计算机用电路实现计算机模型，那就需要和物理电路打交道，需要考虑到 **稳定性**、实现复杂性、还有重要的 **成本**。

尤其在长距离传输的场景下，比如军方通信、还有我们每天都在接触的网络传输，信号的干扰与衰减是一个严重的问题。因为 $r$ 进制数需要用 $r$ 个状态来表示，假如使用电压来表示状态，需要用 $r$ 个区间来分别表示，而信号的干扰与衰减可能造成“误码”的情况，比如发送的是 3，而因为电压衰减收到的却是 2，因此对于传输的信息进行检查与纠正是一个重要的研究领域。当 $r$ 变大时，出现误码的可能性与检查、纠正的成本都会增加，对电子器件的精度和稳定性要求都要提高，电路设计的复杂性也会提升。

除了计算机使用的二进制，程序员也经常使用十六进制与八进制。因为 16 与 8 都是 2 的幂，在进制转换时非常方便，并且有时二进制数位数太多，而对应的十六进制数与八进制数位数少，方便浏览与计算。

> 💡 **NOTE**: 通常规定十六进制的数符为 0-9, A-F，其中 A-F 对应于十进制中的 10-15。

### 硬件——从理论到实际，从抽象到具体

现代电子计算机中所采用的电子元器件是“大规模和超大规模集成电路”。

*集成电路 或称 单片集成电路（**Integrated Circuit** or **Monolithic Integrated Circuit** ，also called **IC**、**Chip** or **Microchip**）* 是位于 **半导体** 材料（通常为硅）的一个小平板（“芯片”）上的 **一组** 电子电路。集成电路技术把一个电路中所需的电子元件及布线互连在一起，然后镶嵌在半导体基片上，然后再封裝（Packaging，可以理解为打包），成为一个具有电路功能的微型结构，这导致电路比由分立电子元件构成的电路更小、更快且更便宜——从而计算机可以从原来占用几间屋子的大型机演变为现在的个人计算机甚至嵌入式系统，比如手机。自从集成电路诞生以来，使用集成的晶体管数量来定义其规模，经历了集成电路——中规模集成电路——大规模集成电路——超大规模集成电路的发展过程（~~工程师的语言如此贫乏~~）。

> 💡 **NOTE**: 你可以认为集成电路既是一个“小型”电路又是一个“大型”电路，“小型”是指其所占物理空间很小，“大型”是指其中的电路（逻辑上）非常复杂

> 🔆 **HINT**：请注意这里提到的“封装”，“封装”即把一些东西打包，从而可以不关心其内部是如何实现的，仅关心它对外提供的接口——如何输入与输出什么、可以重复使用这一模块而不需要每次都从头实现。“封装”这一思想贯彻于整个计算机科学中，从硬件到软件，是计算机科学能够提高工作效率、减少重复劳动的关键之一。

下面是集成电路的实物照片，可以看到在芯片周围排列有长长的管脚，被称为 *引脚（Pin）*，它们就是封装好的集成电路的对外接口，用于输入输出。

<table><tr>
<td>
<img src="/img/beginner/Microchips.jpg" width = "200" height = "150" alt="Microchips" align=center />
</td>
<td>
<img src="/img/beginner/Chip-AD570JD.jpg" width = "200" height = "150" alt="Chip" align=center />
</td>
</tr></table>

想要了解更多历史，可以参考 [History of computing hardware](https://en.wikipedia.org/wiki/History_of_computing_hardware) 或 [计算机硬件历史](https://www.wikiwand.com/zh-sg/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A1%AC%E9%AB%94%E6%AD%B7%E5%8F%B2)

如果你是计算机与电子电气相关专业的同学，电路三件套（电路原理、模拟电子技术、数字电子技术）会带你走向~~挂科~~电子电路的神奇世界。

#### 快速计算——算术与逻辑单元

我们首先从可以执行 **基本逻辑运算** 的 *门（Gate）电路 或称 逻辑门（Logic Gate）电路* 开始介绍。通常而言 *基本逻辑运算* 指的是三种逻辑运算：**与**（同时为真）、**或**（至少一个为真）、**非**（和你反着来）。

门电路是现代电子计算机的 building blocks ，就像建造大楼的砖块。

> 💡 **NOTE**: 逻辑运算的变量值仅为真（True）和假（False）两种真值（Truth Values），其操作数为 True 或 False 中的一种，结果也为 True 或 False 中的一种。做一个对比，（定义在自然数范围上的）算术运算的变量值为自然数，其操作数为一个自然数，结果也为一个自然数。如果你了解抽象代数，可以知道真值集合与逻辑运算同样构成一个代数系统，称为逻辑代数或布尔代数。

下面是一个 *非门（Not Gate）* （又称反相器，Inverter）的例子：

这是非门的电路符号，像这种约定俗成的符号就是工程师的“语言”，即使两个工程师说不同的（自然）语言，它们同样可以通过电路图（或工程图）来“交流”。这种约定在日常生活中也很常见，~~比如你看到 "yysy" 就知道这是“有一说一”的意思~~（在初中物理的电路中你也见过，比如用小方块代表电阻，两条等长的竖线表示电容）

<img src="/img/beginner/NOT_gate.png" width = "200" height = "150" alt="NOT gate symbol" align=center />

你同样可以把它看成一个“函数”，其输入逻辑值（又称布尔值，Boolean）假（False）或 真（True），或者是二进制的 0 或 1，其输出是输入的“反相”，一般我们使用被称为 *真值表（Truth Table）* 的方式来描述逻辑门的输入与输出：

| 输入 $A$ | 输出 $Y$ |
| -------- | -------- |
| Flase | True |
| True | False |

或者：

| 输入 $A$ | 输出 $Y$ |
| -------- | -------- |
| 0 | 1 |
| 1 | 0 |

> 💡 **NOTE**: 在二进制计算机中 0 和 1 可以被用来代表逻辑值 False 和 True，但是表示 **数值** 的 0 和 1 与表示 **逻辑值** 的 0 和 1 是完全不同的东西！而在计算机的具体电路中，又是使用高电平（低电平）和低电平（高电平）来表示 0 和 1 的。

上面的非门符号表示的是一个抽象的概念，真值表只是描述了非门的行为，定义了非门的输入输出接口规范，而其具体电路 **实现** （看看就行）可能有多种，比如最简单的开关电路（就是初中物理实验用的那种手动开关）

<img src="/img/beginner/NOT_simple.png" width = "150" height = "100" alt="开关实现的非门" align=center />

然而在计算机的电路中我们不可能手动进行输入，集成电路的微型结构也不允许。我们需要可以通过其他电路产生的输出（然后被输入到反相器）得到结果的实现方式，也即通过高低电平驱动~~而非人工驱动~~，下面有一些实际中会采用的电路，它们都应用了其他电子元器件比如 NMOS、三极管的特性。

<table><tr>
    <td>
        <img src="/img/beginner/NOT_NMOS.png" width = "150" height = "150" alt="NMOS 实现的非门" align=center />
        <p></p>
        <span>使用 NMOS 实现的非门</span>
    </td>
        <td><img src="/img/beginner/NOT_Transistor.png" width = "250" height = "250" alt="三极管实现的非门" align=center />
        <p></p>
        <span>使用三极管实现的非门</span>
    </td>
</tr></table>

> 🔆 **HINT**：请注意 **接口规范** 与 **具体实现** 的区别，与封装这一思想同样被广泛应用于计算机科学的各个领域。同一规范（标准）可能有很多不同的实现，比如上面的逻辑门，其它的例子有编程语言，同一编程语言有不同实现方式的编译器（或解释器）。接口规范只告诉你“做什么”，而不会告诉你“怎么做”。

使用基本的逻辑门，我们可以构造复杂的系统实现更复杂的逻辑运算乃至 **算术运算** 与其他功能，上面提到的集成电路上就有大量的门电路。

计算机系统里速度最快的 *中央执行单元（Central Processing Unit, CPU）* 中负责执行各种逻辑运算与算术运算的部分就是 *算术逻辑单元（arithmetic logic unit，ALU）*，大量复杂的运算最终都被分解为在特定计算机系统中规定好的这些基本运算（属于计算机指令系统的一部分，有关指令的内容会在下文作详细介绍），而 ALU 就是由门电路搭建的。

下面是一个逻辑门实现基本算术运算的例子：一位全加器，其功能是输入只有一位的两个二进制数 $A$ 与 $B$ 相加，与低位来的一位进位 $C_{in}$，输出该位的计算结果 $S$ 与应该向高位的进位 $C_{out}$。把 $n$ 个一位全加器依次相连，每一个一位全加器向高位的进位输出 $C_{out}$ 连接到下一个一位全加器的低位进位输入 $C_{in}$，就可以实现两个 $n$ 位二进制数的相加。实际上这就是小学学过的加法计算过程。而使用门电路，你还可以设计三个二进制数相加、四个二进制数相加的电路（但必须是固定个数的二进制数相加！）

<table><tr>
    <td>
        <img src="/img/beginner/1bit_FullAdder_Symbol.PNG" width = "250" height = "250" alt="1 位全加器的符号" align=center />
        <p></p>
        <span>1 位全加器的符号</span>
    </td>
        <td><img src="/img/beginner/1bit_FullAdder_Circuit.PNG" width = "420" height = "420" alt="1 位全加器的电路" align=center />
        <p></p>
        <span>逻辑门实现的 1 位全加器的电路图</span>
    </td>
</tr></table>

> 💡 **NOTE**: 为什么可以使用基本逻辑运算的门电路来实现算术运算呢？一个原因是上面提到的计算机使用 1 和 0 分别代表 True 和 False，从而同样的 1 和 0 在逻辑运算中可以被看做逻辑值，而在算术运算中可以被看做数值（不同语义！）。而另一个原因需要你了解逻辑代数与数字电路的基础知识。总之你现在只需要知道，逻辑运算与算术运算的输入输出值使用的符号形式（0 和 1）是相同的，而其中复杂的实现交给工程师就好了。

一台主频为 $2 GHz$ 的计算机，每秒最多能够进行的基本（逻辑与算术）运算次数是 20 亿次。

> 💡 **NOTE**: 在 Windows 操作系统上右击开始图标，选择 Windows PowerShell，在弹出的命令行界面中执行 `systeminfo` 命令，可以在处理器这一项中找到你的电脑 CPU 主频。

通常由各种逻辑门构建起来的电路被称为 *组合电路（Combinational Circuit）*，其特点是输出 **即时响应** 输入（逻辑上，工程中会有传播延迟的情况，请参考电磁波的传播速度）与 **无记忆性**。

然而计算理论告诉我们，无记忆的机器与我们希望的机器（图灵机——理论上可以解决所有可计算问题的机器，其与组合电路在计算理论中对应的有限状态自动机的区别之一就是是否能够“记忆”）相差甚远，甚至不能实现一些很简单的任务，比如：

**把 n 个数相加，这里 n 也是待输入的变量（而不是某个固定的数）！**

**存储** 可以解决这个问题，我们离梦想中的图灵机更进一步了。

#### 存储

<!--实际的计算机存储是有限的

`https://zh.wikipedia.org/wiki/图_(数学)`

`https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)`-->

## 编程：实践是学习计算机的最佳途径

自然语言是用于人与人之间交流的语言，你也可以认为编程语言就是用于人与计算机之间交流的语言。

特定编程语言对应的 *编译器* 或 *解释器*（相关概念在下文中会进行解释）只是一个分析其编程语言语法的 **程序**，这样的程序无法理解语言的语义（所以有时你会发现编译通过而调试结果与预期不符，因为你可能打错了什么字符，但有些“智能”的编译器会在一些问题上给出警告），在自然语言中你可能使用一些不符合语言语法的表述（~~比如倒装句~~），然而对方仍然能够理解你的意思。但编译器可不行！如果你的源代码文件不符合编程语言的语法，编译器只会报错。

所以当你发现编译器报错，或者程序调试出现 Bug 的时候，一定是你错了（~~或者你使用的包本身就有 Bug~~），而不是编译器或计算机（除非你已经是达到可以~~警告编译器~~境界的编程高手了，~~而这时候你应该不会在阅读我这个菜鸟写的文章~~），请老老实实查阅相关资料，找到问题所在吧！

> 💡 **NOTE**: 对于编译器的工作可以这样理解：编译器这一检查语法的程序执行的是严格定义的 **算法（Algorithm）**，而像自然语言处理这样试图理解语义的方向使用的是 **启发式算法（Heuristic）**，虽然我们经常看到有人使用算法来描述它们，但是 algorithm 和 heuristic 是有本质不同的！algorithm 的其中一个要求是 **正确性**，而 heuristic 并不能保证得到正确的结果！深度学习中的算法都属于 heuristic

形式语言中的字符与编程语言常说的字符

形式语言中的字符串与编程语言中的数据结构字符串

### 计算机的语言：机器语言